{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { useState, useEffect, useRef } from \"react\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { createNavigationContainerRef } from \"@react-navigation/native\";\nexport var RootNavigation = {\n  navigate: function navigate(_name, _params) {},\n  goBack: function goBack() {},\n  resetRoot: function resetRoot(_state) {},\n  getRootState: function getRootState() {\n    return {};\n  },\n  dispatch: function dispatch(_action) {}\n};\nexport var navigationRef = createNavigationContainerRef();\nexport function getActiveRouteName(state) {\n  var route = state.routes[state.index];\n  if (!route.state) return route.name;\n  return getActiveRouteName(route.state);\n}\nexport function useBackButtonHandler(canExit) {\n  var canExitRef = useRef(canExit);\n  useEffect(function () {\n    canExitRef.current = canExit;\n  }, [canExit]);\n  useEffect(function () {\n    var onBackPress = function onBackPress() {\n      if (!navigationRef.isReady()) {\n        return false;\n      }\n\n      var routeName = getActiveRouteName(navigationRef.getRootState());\n\n      if (canExitRef.current(routeName)) {\n        BackHandler.exitApp();\n        return true;\n      }\n\n      if (navigationRef.canGoBack()) {\n        navigationRef.goBack();\n        return true;\n      }\n\n      return false;\n    };\n\n    BackHandler.addEventListener(\"hardwareBackPress\", onBackPress);\n    return function () {\n      return BackHandler.removeEventListener(\"hardwareBackPress\", onBackPress);\n    };\n  }, []);\n}\nexport function useNavigationPersistence(storage, persistenceKey) {\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      initialNavigationState = _useState2[0],\n      setInitialNavigationState = _useState2[1];\n\n  var _useState3 = useState(!__DEV__),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isRestored = _useState4[0],\n      setIsRestored = _useState4[1];\n\n  var routeNameRef = useRef();\n\n  var onNavigationStateChange = function onNavigationStateChange(state) {\n    var previousRouteName = routeNameRef.current;\n    var currentRouteName = getActiveRouteName(state);\n\n    if (previousRouteName !== currentRouteName) {\n      __DEV__ && console.tron.log(currentRouteName);\n    }\n\n    routeNameRef.current = currentRouteName;\n    storage.save(persistenceKey, state);\n  };\n\n  var restoreState = function restoreState() {\n    var state;\n    return _regeneratorRuntime.async(function restoreState$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(storage.load(persistenceKey));\n\n          case 3:\n            state = _context.sent;\n            if (state) setInitialNavigationState(state);\n\n          case 5:\n            _context.prev = 5;\n            setIsRestored(true);\n            return _context.finish(5);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0,, 5, 8]], Promise);\n  };\n\n  useEffect(function () {\n    if (!isRestored) restoreState();\n  }, [isRestored]);\n  return {\n    onNavigationStateChange: onNavigationStateChange,\n    restoreState: restoreState,\n    isRestored: isRestored,\n    initialNavigationState: initialNavigationState\n  };\n}\nexport function navigate(name, params) {\n  if (navigationRef.isReady()) {\n    navigationRef.navigate(name, params);\n  }\n}\nexport function goBack() {\n  if (navigationRef.isReady() && navigationRef.canGoBack()) {\n    navigationRef.goBack();\n  }\n}\nexport function resetRoot() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    index: 0,\n    routes: []\n  };\n\n  if (navigationRef.isReady()) {\n    navigationRef.resetRoot(params);\n  }\n}","map":{"version":3,"names":["useState","useEffect","useRef","createNavigationContainerRef","RootNavigation","navigate","_name","_params","goBack","resetRoot","_state","getRootState","dispatch","_action","navigationRef","getActiveRouteName","state","route","routes","index","name","useBackButtonHandler","canExit","canExitRef","current","onBackPress","isReady","routeName","BackHandler","exitApp","canGoBack","addEventListener","removeEventListener","useNavigationPersistence","storage","persistenceKey","initialNavigationState","setInitialNavigationState","__DEV__","isRestored","setIsRestored","routeNameRef","onNavigationStateChange","previousRouteName","currentRouteName","console","tron","log","save","restoreState","load","params"],"sources":["D:/Projects/Projects Hub/resoc-nativeapp/ResocAppex/app/navigators/navigation-utilities.tsx"],"sourcesContent":["import { useState, useEffect, useRef } from \"react\"\nimport { BackHandler } from \"react-native\"\nimport {\n  PartialState,\n  NavigationState,\n  NavigationAction,\n  createNavigationContainerRef,\n} from \"@react-navigation/native\"\n\n/* eslint-disable */\nexport const RootNavigation = {\n  navigate(_name: string, _params?: any) {},\n  goBack() {},\n  resetRoot(_state?: PartialState<NavigationState> | NavigationState) {},\n  getRootState(): NavigationState {\n    return {} as any\n  },\n  dispatch(_action: NavigationAction) {},\n}\n/* eslint-enable */\n\nexport const navigationRef = createNavigationContainerRef()\n\n/**\n * Gets the current screen from any navigation state.\n */\nexport function getActiveRouteName(state: NavigationState | PartialState<NavigationState>) {\n  const route = state.routes[state.index]\n\n  // Found the active route -- return the name\n  if (!route.state) return route.name\n\n  // Recursive call to deal with nested routers\n  return getActiveRouteName(route.state)\n}\n\n/**\n * Hook that handles Android back button presses and forwards those on to\n * the navigation or allows exiting the app.\n */\nexport function useBackButtonHandler(canExit: (routeName: string) => boolean) {\n  const canExitRef = useRef(canExit)\n\n  useEffect(() => {\n    canExitRef.current = canExit\n  }, [canExit])\n\n  useEffect(() => {\n    // We'll fire this when the back button is pressed on Android.\n    const onBackPress = () => {\n      if (!navigationRef.isReady()) {\n        return false\n      }\n\n      // grab the current route\n      const routeName = getActiveRouteName(navigationRef.getRootState())\n\n      // are we allowed to exit?\n      if (canExitRef.current(routeName)) {\n        // exit and let the system know we've handled the event\n        BackHandler.exitApp()\n        return true\n      }\n\n      // we can't exit, so let's turn this into a back action\n      if (navigationRef.canGoBack()) {\n        navigationRef.goBack()\n        return true\n      }\n\n      return false\n    }\n\n    // Subscribe when we come to life\n    BackHandler.addEventListener(\"hardwareBackPress\", onBackPress)\n\n    // Unsubscribe when we're done\n    return () => BackHandler.removeEventListener(\"hardwareBackPress\", onBackPress)\n  }, [])\n}\n\n/**\n * Custom hook for persisting navigation state.\n */\nexport function useNavigationPersistence(storage: any, persistenceKey: string) {\n  const [initialNavigationState, setInitialNavigationState] = useState()\n\n  // This feature is particularly useful in development mode.\n  // It is selectively enabled in development mode with\n  // the following approach. If you'd like to use navigation persistence\n  // in production, remove the __DEV__ and set the state to false\n  const [isRestored, setIsRestored] = useState(!__DEV__)\n\n  const routeNameRef = useRef<string | undefined>()\n\n  const onNavigationStateChange = (state) => {\n    const previousRouteName = routeNameRef.current\n    const currentRouteName = getActiveRouteName(state)\n\n    if (previousRouteName !== currentRouteName) {\n      // track screens.\n      __DEV__ && console.tron.log(currentRouteName)\n    }\n\n    // Save the current route name for later comparision\n    routeNameRef.current = currentRouteName\n\n    // Persist state to storage\n    storage.save(persistenceKey, state)\n  }\n\n  const restoreState = async () => {\n    try {\n      const state = await storage.load(persistenceKey)\n      if (state) setInitialNavigationState(state)\n    } finally {\n      setIsRestored(true)\n    }\n  }\n\n  useEffect(() => {\n    if (!isRestored) restoreState()\n  }, [isRestored])\n\n  return { onNavigationStateChange, restoreState, isRestored, initialNavigationState }\n}\n\n/**\n * use this to navigate without the navigation\n * prop. If you have access to the navigation prop, do not use this.\n * More info: https://reactnavigation.org/docs/navigating-without-navigation-prop/\n */\nexport function navigate(name: any, params?: any) {\n  if (navigationRef.isReady()) {\n    navigationRef.navigate(name as never, params as never)\n  }\n}\n\nexport function goBack() {\n  if (navigationRef.isReady() && navigationRef.canGoBack()) {\n    navigationRef.goBack()\n  }\n}\n\nexport function resetRoot(params = { index: 0, routes: [] }) {\n  if (navigationRef.isReady()) {\n    navigationRef.resetRoot(params)\n  }\n}\n"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,MAA9B,QAA4C,OAA5C;;AAEA,SAIEC,4BAJF,QAKO,0BALP;AAQA,OAAO,IAAMC,cAAc,GAAG;EAC5BC,QAD4B,oBACnBC,KADmB,EACJC,OADI,EACW,CAAE,CADb;EAE5BC,MAF4B,oBAEnB,CAAE,CAFiB;EAG5BC,SAH4B,qBAGlBC,MAHkB,EAGwC,CAAE,CAH1C;EAI5BC,YAJ4B,0BAII;IAC9B,OAAO,EAAP;EACD,CAN2B;EAO5BC,QAP4B,oBAOnBC,OAPmB,EAOQ,CAAE;AAPV,CAAvB;AAWP,OAAO,IAAMC,aAAa,GAAGX,4BAA4B,EAAlD;AAKP,OAAO,SAASY,kBAAT,CAA4BC,KAA5B,EAAoF;EACzF,IAAMC,KAAK,GAAGD,KAAK,CAACE,MAAN,CAAaF,KAAK,CAACG,KAAnB,CAAd;EAGA,IAAI,CAACF,KAAK,CAACD,KAAX,EAAkB,OAAOC,KAAK,CAACG,IAAb;EAGlB,OAAOL,kBAAkB,CAACE,KAAK,CAACD,KAAP,CAAzB;AACD;AAMD,OAAO,SAASK,oBAAT,CAA8BC,OAA9B,EAAuE;EAC5E,IAAMC,UAAU,GAAGrB,MAAM,CAACoB,OAAD,CAAzB;EAEArB,SAAS,CAAC,YAAM;IACdsB,UAAU,CAACC,OAAX,GAAqBF,OAArB;EACD,CAFQ,EAEN,CAACA,OAAD,CAFM,CAAT;EAIArB,SAAS,CAAC,YAAM;IAEd,IAAMwB,WAAW,GAAG,SAAdA,WAAc,GAAM;MACxB,IAAI,CAACX,aAAa,CAACY,OAAd,EAAL,EAA8B;QAC5B,OAAO,KAAP;MACD;;MAGD,IAAMC,SAAS,GAAGZ,kBAAkB,CAACD,aAAa,CAACH,YAAd,EAAD,CAApC;;MAGA,IAAIY,UAAU,CAACC,OAAX,CAAmBG,SAAnB,CAAJ,EAAmC;QAEjCC,WAAW,CAACC,OAAZ;QACA,OAAO,IAAP;MACD;;MAGD,IAAIf,aAAa,CAACgB,SAAd,EAAJ,EAA+B;QAC7BhB,aAAa,CAACN,MAAd;QACA,OAAO,IAAP;MACD;;MAED,OAAO,KAAP;IACD,CAtBD;;IAyBAoB,WAAW,CAACG,gBAAZ,CAA6B,mBAA7B,EAAkDN,WAAlD;IAGA,OAAO;MAAA,OAAMG,WAAW,CAACI,mBAAZ,CAAgC,mBAAhC,EAAqDP,WAArD,CAAN;IAAA,CAAP;EACD,CA/BQ,EA+BN,EA/BM,CAAT;AAgCD;AAKD,OAAO,SAASQ,wBAAT,CAAkCC,OAAlC,EAAgDC,cAAhD,EAAwE;EAC7E,gBAA4DnC,QAAQ,EAApE;EAAA;EAAA,IAAOoC,sBAAP;EAAA,IAA+BC,yBAA/B;;EAMA,iBAAoCrC,QAAQ,CAAC,CAACsC,OAAF,CAA5C;EAAA;EAAA,IAAOC,UAAP;EAAA,IAAmBC,aAAnB;;EAEA,IAAMC,YAAY,GAAGvC,MAAM,EAA3B;;EAEA,IAAMwC,uBAAuB,GAAG,SAA1BA,uBAA0B,CAAC1B,KAAD,EAAW;IACzC,IAAM2B,iBAAiB,GAAGF,YAAY,CAACjB,OAAvC;IACA,IAAMoB,gBAAgB,GAAG7B,kBAAkB,CAACC,KAAD,CAA3C;;IAEA,IAAI2B,iBAAiB,KAAKC,gBAA1B,EAA4C;MAE1CN,OAAO,IAAIO,OAAO,CAACC,IAAR,CAAaC,GAAb,CAAiBH,gBAAjB,CAAX;IACD;;IAGDH,YAAY,CAACjB,OAAb,GAAuBoB,gBAAvB;IAGAV,OAAO,CAACc,IAAR,CAAab,cAAb,EAA6BnB,KAA7B;EACD,CAdD;;EAgBA,IAAMiC,YAAY,GAAG,SAAfA,YAAe;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA;YAAA,iCAEGf,OAAO,CAACgB,IAAR,CAAaf,cAAb,CAFH;;UAAA;YAEXnB,KAFW;YAGjB,IAAIA,KAAJ,EAAWqB,yBAAyB,CAACrB,KAAD,CAAzB;;UAHM;YAAA;YAKjBwB,aAAa,CAAC,IAAD,CAAb;YALiB;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAArB;;EASAvC,SAAS,CAAC,YAAM;IACd,IAAI,CAACsC,UAAL,EAAiBU,YAAY;EAC9B,CAFQ,EAEN,CAACV,UAAD,CAFM,CAAT;EAIA,OAAO;IAAEG,uBAAuB,EAAvBA,uBAAF;IAA2BO,YAAY,EAAZA,YAA3B;IAAyCV,UAAU,EAAVA,UAAzC;IAAqDH,sBAAsB,EAAtBA;EAArD,CAAP;AACD;AAOD,OAAO,SAAS/B,QAAT,CAAkBe,IAAlB,EAA6B+B,MAA7B,EAA2C;EAChD,IAAIrC,aAAa,CAACY,OAAd,EAAJ,EAA6B;IAC3BZ,aAAa,CAACT,QAAd,CAAuBe,IAAvB,EAAsC+B,MAAtC;EACD;AACF;AAED,OAAO,SAAS3C,MAAT,GAAkB;EACvB,IAAIM,aAAa,CAACY,OAAd,MAA2BZ,aAAa,CAACgB,SAAd,EAA/B,EAA0D;IACxDhB,aAAa,CAACN,MAAd;EACD;AACF;AAED,OAAO,SAASC,SAAT,GAAsD;EAAA,IAAnC0C,MAAmC,uEAA1B;IAAEhC,KAAK,EAAE,CAAT;IAAYD,MAAM,EAAE;EAApB,CAA0B;;EAC3D,IAAIJ,aAAa,CAACY,OAAd,EAAJ,EAA6B;IAC3BZ,aAAa,CAACL,SAAd,CAAwB0C,MAAxB;EACD;AACF"},"metadata":{},"sourceType":"module"}