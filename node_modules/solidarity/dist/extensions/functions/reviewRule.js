"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
module.exports = (requirement, report, context) => __awaiter(void 0, void 0, void 0, function* () {
    const { tail, pipe, flatten, map } = require('ramda');
    const skipRule = require('./skipRule');
    const checkDir = require('./checkDir');
    const checkFile = require('./checkFile');
    const checkShell = require('./checkShell');
    const findPluginInfo = require('./findPluginInfo');
    const { print, solidarity } = context;
    const { colors, checkmark, xmark } = print;
    const prettyBool = (checkingFunction) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            yield checkingFunction();
            return checkmark + colors.green(' YES');
        }
        catch (e) {
            return xmark + colors.red(' NO');
        }
    });
    const rules = pipe(tail, 
    // @ts-ignore - flatten will never get a string bc tail is called first
    flatten)(requirement);
    // check each rule for report
    const ruleChecks = map((rule) => __awaiter(void 0, void 0, void 0, function* () {
        // Make sure this rule is active
        if (skipRule(rule))
            return false;
        switch (rule.rule) {
            // Handle CLI rule report
            case 'cli':
                let binaryVersion;
                try {
                    binaryVersion = yield solidarity.getVersion(rule, context);
                }
                catch (_e) {
                    binaryVersion = colors.red('*UNKNOWN*');
                }
                report.addCLI({
                    binary: rule.binary,
                    version: binaryVersion,
                    desired: rule.semver,
                });
                break;
            // Handle ENV rule report
            case 'env':
                const envValue = process.env[rule.variable] || colors.red('*UNDEFINED*');
                report.envRules.push([`$${rule.variable}`, envValue]);
                break;
            // Handle dir rule report
            case 'directory':
            case 'dir':
                const dirExists = yield prettyBool(() => __awaiter(void 0, void 0, void 0, function* () { return checkDir(rule, context); }));
                report.filesystemRules.push([rule.location, 'Dir', dirExists]);
                break;
            // Handle file rule report
            case 'file':
                const fileExists = yield prettyBool(() => __awaiter(void 0, void 0, void 0, function* () { return checkFile(rule, context); }));
                report.filesystemRules.push([rule.location, 'File', fileExists]);
                break;
            case 'shell':
                const shellCheckPass = yield prettyBool(() => __awaiter(void 0, void 0, void 0, function* () { return checkShell(rule, context); }));
                report.shellRules.push([rule.command, rule.match, shellCheckPass]);
                break;
            case 'custom':
                const customPluginRule = findPluginInfo(rule, context);
                if (customPluginRule.success) {
                    // let plugin update the report
                    if (customPluginRule.plugin.report)
                        yield customPluginRule.plugin.report(rule, context, report);
                }
                else {
                    throw new Error(customPluginRule.message);
                }
                break;
            default:
                throw new Error('Encountered unknown rule');
        }
    }), rules);
    // Run all the rule checks for a requirement
    return Promise.all(ruleChecks).then(results => {
        return results;
    });
});
//# sourceMappingURL=reviewRule.js.map